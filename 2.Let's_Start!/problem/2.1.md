<!--
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
-->

## マージソートにあらわれる小配列上の挿入ソート
>マージソートの最悪実行時間は、 $\Theta(n \lg n)$ 、挿入ソートの最悪実行時間は、 $\Theta(O^2)$ であるが、挿入ソートの方が定数因子が小さいので、問題サイズが小さい時には、挿入ソートの方が多くのコンピュータ上で高速に実行できる。そこで、部分問題が十分小さくなった時に、マージソートの中で挿入ソートを用いて再起の底を上げる意義がある。 $\frac{n}{k}$ 個のそれぞれの長さ $k$ の部分リストを挿入ソートを用いてソートし、その後は標準的な方法でマージを行うようにマージソートを改良する。ここで最適な $k$ の値は後で決定される。

>a.$n/k$ 個のそれぞれの長さ $k$ の部分リストは、挿入ソートにより最悪時に $\Theta(nk)$ 時間でソートできることを示せ。

$$
n/k \cdot O(k^2) = O(nk)
$$

>b.ソート済みの $n/k$ 個の部分リストは最悪時に $\Theta(n \lg (n/k))$ 時間でマージできることを示せ。

$n/k$ 個のリストから 最小要素を効率的に取り出す必要があるのでヒープを用いる。ヒープを使うと最小要素の取得・更新を

$$
O(\lg\frac{n}{k})
$$

で行えるので、
これを $𝑛$ 回繰り返すことで、トータル時間は、

$$
O(n \cdot \lg\frac{n}{k})
$$

となる。

>c.改良アルゴリズムの最悪実行時間を $\Theta(nk+n \lg (n/k))$ とする。改良アルゴリズムが標準的なマージソートと同じ漸近的実行時間を持つという条件のもとで、$k$ が取りうる最大値を $n$ の関数として $\Theta$ 記法で示せ。

改良アルゴリズムの計算量を標準マージソートの $Θ(nlogn)$ に一致させる必要があるので、

$$
\Theta(n \cdot k + n \cdot log\frac{n}{k}) = \Theta(n \lg n)
$$

を満たす必要がある。

最悪の計算量を考慮する。

$$
n \cdot k + n \cdot log\frac{n}{k} \leq n \lg n
$$

マージソートと同じ計算量に抑えるためには

$$
n \cdot k  \ll n \lg n
$$

を満たす必要があるので、

$$
k  \ll \lg n
$$

が成り立つ。

よって、$k$ の最大値は、$\Theta(\lg n)$である。

>d.実際には $k$ の値をどのように選ぶべきか。

$k$ は、マージソートで部分リストを挿入ソートする際の最大サイズである。
部分リストのサイズが $k$ 以下になったら、再帰の底で 挿入ソート に切り替える。挿入ソートの最悪時間は $\Theta(O^2)$ であるが、小さな配列に対しては挿入ソートの定数因子が小さく高速なので、マージソートの再帰を底上げすることで、全体の計算量を改善したい。

Timsort では、$k$ を 32 や 64 に固定することで、多くの配列で最適な結果が得られたそう。多くのプラットフォームやハードウェアでのキャッシュ効率をテストして得られた値なのだろうか。キャッシュサイズやプロセッサの特性によって、$k$ の最適値は変動するので、$k$をキャッシュラインサイズやブロックサイズに合わせて調整することが大事かもしれない。